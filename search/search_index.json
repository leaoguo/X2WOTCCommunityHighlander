{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"X2WOTCCommunityHighlander Documentation Current status of the Documentation The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page. How to read The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is Documentation for the documentation tool We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\\\.scripts\\\\make_docs.py .\\\\X2WOTCCommunityHighlander\\\\Src\\\\ .\\\\X2WOTCCommunityHighlander\\\\Config\\\\ --outdir .\\\\target\\\\ --docsdir .\\\\docs_src\\\\ or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request. Inline Documentation The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files. Syntax Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation. Feature definitions A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>... Feature references If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well. Complete example (Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance Tags You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag. Bugfixes The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#x2wotccommunityhighlander-documentation","text":"","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#current-status-of-the-documentation","text":"The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page.","title":"Current status of the Documentation"},{"location":"#how-to-read","text":"The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is","title":"How to read"},{"location":"#documentation-for-the-documentation-tool","text":"We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\\\.scripts\\\\make_docs.py .\\\\X2WOTCCommunityHighlander\\\\Src\\\\ .\\\\X2WOTCCommunityHighlander\\\\Config\\\\ --outdir .\\\\target\\\\ --docsdir .\\\\docs_src\\\\ or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request.","title":"Documentation for the documentation tool"},{"location":"#inline-documentation","text":"The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files.","title":"Inline Documentation"},{"location":"#syntax","text":"Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation.","title":"Syntax"},{"location":"#feature-definitions","text":"A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>...","title":"Feature definitions"},{"location":"#feature-references","text":"If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well.","title":"Feature references"},{"location":"#complete-example","text":"(Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance","title":"Complete example"},{"location":"#tags","text":"You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag.","title":"Tags"},{"location":"#bugfixes","text":"The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry","title":"Bugfixes"},{"location":"Bugfixes/","text":"Bugfixes This page accomodates all bug fixes that do not deserve their own documentation page, as they are simple enough to be entirely explained by a single line. #20 - X2Ability.uc:1443-1444 : Reaper's Banish now properly visualizes subsequent shots. #33 - XGUnitNativeBase.uc:543-544 : Gremlins owned by AI units now correctly use fast walk animations even if their owner is in Red Alert #36 - X2TacticalGameRuleset.uc:4690-4691 : Do not clear Reinforcements' \"Summoning Sickness\" when interrupted by Skirmisher, denying them an erronous bonus turn. #51 - XComGameState_AdventChosen.uc:264-265 : Prevent Assassin from gaining perks incompatible with forced \"Shadowstep\" in Lost and Abandoned #55 - CHItemSlot.uc:346-347 : Check a soldier's NeedsSecondaryWeapon everywhere instead of hardcoding based on Rookie rank #70 - CharacterPoolManager.uc:447-448 : CharacterPoolManager:CreateCharacter now honors ForceCountry #95 - XComGameState_Unit.uc:13129-13130 : ResetRankToRookie now correctly applies Beta Strike HP bonuses #160 - UIOptionsPCScreen.uc:3145-3146 : UIOptionsPCScreen now shows all part pack sliders, adding a scroll bar if needed #215 - XGUnit.uc:1450-1451 : Units are now allowed to have personality speech (affected by personality) even below \"Veteran\" rank #269 - XComIdleAnimationStateMachine.uc:1090-1091 : Fix some edge cases in XComIdleAnimationStateMachine regarding idle animations, targeting, and step-outs #273 - X2Ability.uc:1497-1498 : Fix an issue causing Rapid Fire/Chain Shot/Banish/... entering cover early #303 - UITooltipInfoList.uc:98-99 : UITooltipInfoList no longer displays stale data like weapon upgrades from other units #318 - X2Camera_Cinescript.uc:528-529 : Fix Cinescript CutAfterPrevious not working in combination with MatineeReplacements , breaking Spark BIT hack camera #326 - X2Action_ApplyWeaponDamageToUnit.uc:187-188 : Allow damage flyovers from weapon-less Psi abilities to use the Psi damage popup #376 - XGUnit.uc:3608-3609 : Gremlins (and other Cosmetic Units) are now correctly tinted and patterned #426 - X2AbilityToHitCalc_StandardAim.uc:196-197 : Fix X2AbilityToHitCalc_StandardAim discarding unfavorable (for XCOM) changes to hit results from effects #493 - X2AbilityToHitCalc_StandardAim.uc:700-701 : Allow REACTION_DASHING_FINALMOD to reduce reaction fire hit chance against dashing targets #503 - XGAIBehavior.uc:9658-9659 : \"Flying\" pod leaders now patrol despite non-flat tiles on their paths #508 - XComGameState_AIGroup.uc:422-423 : Patrol logic now ensures units do not attempt to patrol outside of the map which would cause them to stop patrolling #520 - X2MeleePathingPawn.uc:174-175 : Controller input now allows choosing melee attack destination tile despite floor differences #531 - X2Ability_ChosenAssassin.uc:565-566 : Assassin gains a temporary instead of permanently stacking mobility boost from performing a melee attack #551 - X2Action_SwapTeams.uc:48-49 : Rescue rings no longer disappear on other rescuable units after a neutral unit swaps to team XCom #557 - XComGameState_Unit.uc:2325-2326 : Soldiers that have been carried out of a mission are no longer unable to be carried out of a later mission #608 - XComGameState_Unit.uc:4228-4229 : MergeAmmoAsNeeded now also works for units spawned from the Avenger #613 - UIX2PanelHeader.uc:53-54 : SetText now sends text to flash instead of requiring calling SetHeaderWidth #637 - XComGameState_Unit.uc:14022-14023 : Will recovery project and soldier mental state are now consistent with each other, fixing Shaken/Tired soldiers occasionally recovering instantly #638 - UIScanButton.uc:278-279 : UIScanButton can now work properly when it's a grandchild of UIStrategyMapItem, not only when direct child #644 - X2Ability_DefaultAbilitySet.uc:426-427 : Allow patrolling units to occupy the same tile instead of teleporting to (0,0,0) when out of space, potentially revealing XCOM #648 - UIHackingScreen.uc:410-411 : Cancelling a hack in progress using Esc no longer bypasses Haywire's cooldown","title":"Bugfixes"},{"location":"compatibility/","text":"Compatibility Because the Highlander is a core mod that many different mods on the workshop depend on, it strives to not make any observable changes to the base game (save for bug fixes and features that mods explicitly make use of). However, everything can potentially be a breaking change because the existing behavior rarely has any documentation in the game. Additionally, ModClassOverrides in mods occasionally override functions that were changed in the Highlander, essentially reverting the change and breaking a Highlander feature. As a result, sometimes modders need to pay special attention to Highlander features. This page is a list of pages tagged compatibility , indicating a potential incompatibility. Every page listed here has an section Compatibility that describes the issue and how modders can fix it. #155 - ArmorEquipRollDLCPartChance #257 - OverrideUnitFocusUI #724 - DisplayCustomOverwatchActionPointOnUnitFlag","title":"Compatibility"},{"location":"customization/","text":"Customization This is a list of all pages tagged \"customization\". #155 - ArmorEquipRollDLCPartChance #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #356 - TintMaterialConfigs #397 - ChangeDefaultWeaponColor","title":"Customization"},{"location":"dlc2/","text":"DLC2 DLC2 (also known as DLC_2, DLC_60, AH and Alien Hunters) is the DLC that introduces Alien Rulers into the game. This page contains a list of features that allow mods to control the behaviour of various features included in DLC2.","title":"Dlc2"},{"location":"events/","text":"Events Many of the Highlander's features utilize Event Hooks . Mods can subscribe to any event by name, and then Read some of the data passed with the event Perform actions in response to the event Send data back to the sender of the event Especially the last option is something many Highlander hooks expect mods to do. This is done with the XComLWTuple class. It can contain arbitrary tagged data, can be read and written to by mods. Consider it a polymorphic tuple that is compatible with any event trigger/listener signature. The following is a list of all pages tagged \"Events\" due to their relevance to or use of the event system. #4 - CHEventListenerTemplate #754 - XComLWTuple #814 - ValidateGTSClassTraining #829 - OverrideProjectileInstance #842 - OverrideHasInfiniteAmmo #844 - ShowItemInLockerList","title":"Events"},{"location":"loadoutslots/","text":"Loadout Slots The Highlander has a number of features to add new loadout slots, change existing loadout slot availability, or modify which items can be equipped under which conditions. This is a list of pages tagged \"Loadoutslots\". #118 - CustomInventorySlots #735 - OverrideHasGrenadePocket #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot","title":"Loadout Slots"},{"location":"pawns/","text":"Pawns In the context of XCOM 2, Pawns are the Unreal-3D representation of units and weapons. These Pawns define the 3D meshes and materials, their attachments, animations, and state. A pawn always has an archetype that is usually specified in the template. When a unit or weapon is spawned, a clone of the archetype is created and placed in the 3D world. This leaves mods that want to make modifications with two options: Modify the archetype: The archetype can be dynamically loaded ( RequestGameArchetype / DynamicLoadObject ) by mods for modification. This can, especially with many mods, take a fair while as some mods would have to load every archetype they want to modify. It also interacts badly with the garbage collector, as unused archetypes will be removed from memory and have their changes reverted. Additionally, these changes are static; all future instances will be affected the same and different instances cannot receive individual changes. Modify the instance: The mod finds a way to modify the instance that was just created as a clone. This allows mods to change things that are considered properties of the archetype on a per-instance basis. However, it is difficult to reliably receive a notification when an archetype is cloned and a new instance is created. The Highlander can help with this by triggering events and calling DLC hooks whenever mods may need to change instance properties. This page contains a list of features that can help with pawn modification on a per-instance basis. #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #281 - DLCAppendWeaponSockets #356 - TintMaterialConfigs","title":"Pawns"},{"location":"ui/","text":"User Interface The XCOM 2 user interface is mostly built in flash, but offers custom components that can be used to produce quite sophisticated screens and UI elements. For documentation on base game features, see XCOM 2 War of the Chosen SDK/Documentation/Tech/XCOM2Mods_UserInterface.pdf . However, extending existing UI screens can prove quite difficult, as UI screens do not expose any hooks for extending input handling or navigation help additions. The following features can help with making UI more extensible. #198 - SubscribeToOnInput #501 - SubscribeToOnInputForScreen","title":"User Interface"},{"location":"misc/ArmorEquipRollDLCPartChance/","text":"ArmorEquipRollDLCPartChance Tracking Issue: #155 Tags: customization , compatibility When a unit equips new armor, the game rolls from all customization options, even the ones where the slider for the DLCName is set to 0 . The HL change fixes this. Compatibility If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName Source code references XComGameState_Unit.uc:7680-7694 XComGame.ini:32-32","title":"ArmorEquipRollDLCPartChance"},{"location":"misc/ArmorEquipRollDLCPartChance/#compatibility","text":"If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName","title":"Compatibility"},{"location":"misc/ArmorEquipRollDLCPartChance/#source-code-references","text":"XComGameState_Unit.uc:7680-7694 XComGame.ini:32-32","title":"Source code references"},{"location":"misc/CHEventListenerTemplate/","text":"CHEventListenerTemplate Tracking Issue: #4 Tags: events Allows mods to set up Event Listener classes with specified Deferral and Priority, similar to X2AbilityTrigger_EventListener. The AddCHEvent function accepts up to four arguments: 1) Name of the Event to listen for. 2) EventFn to run when the event is triggered. 3) Optional: Deferral (default deferral is ELD_OnStateSubmitted). Go here for info on Deferrals: https://www.reddit.com/r/xcom2mods/wiki/index/events#wiki_deferral 4) Optional: Priority (default priority is 50). Event listeners with the larger priority number are executed first. Example use: class X2EventListener_YourEventListener extends X2EventListener; static function array<X2DataTemplate> CreateTemplates() { local array<X2DataTemplate> Templates; // You can create any number of Event Listener templates within one X2EventListener class. Templates.AddItem(CreateListenerTemplate_YourListener()); return Templates; } static function CHEventListenerTemplate CreateListenerTemplate_OnBestGearLoadoutApplied() { local CHEventListenerTemplate Template; `CREATE_X2TEMPLATE(class'CHEventListenerTemplate', Template, 'Your_Custom_BestGearApplied_Listener'); // Whether this Listener should be active during tactical missions. Template.RegisterInTactical = true; // Whether this Listener should be active on the strategic layer (while on Avenger) Template.RegisterInStrategy = true; Template.AddCHEvent('EventName', YourEventFn_Listener, ELD_Immediate, 50); return Template; } static function EventListenerReturn YourEventFn_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) { // Perform actions if the event was triggered during interruption stage. } else { // Perform actions outside interruption stage (after an ability was successfully activated, for example) } return ELR_NoInterrupt; } Source code references CHEventListenerTemplate.uc:2-53","title":"CHEventListenerTemplate"},{"location":"misc/CHEventListenerTemplate/#source-code-references","text":"CHEventListenerTemplate.uc:2-53","title":"Source code references"},{"location":"misc/ChangeDefaultWeaponColor/","text":"ChangeDefaultWeaponColor Tracking Issue: #397 Tags: customization Soldiers with randomly generated appearance get the beige weapon color by default (color number 20). This change moves the default weapon color number to XComContent.ini , where it can be changed by mods or by the player manually. [XComGame.XGCharacterGenerator] iDefaultWeaponTint = 20 Source code references XGCharacterGenerator.uc:858-865","title":"ChangeDefaultWeaponColor"},{"location":"misc/ChangeDefaultWeaponColor/#source-code-references","text":"XGCharacterGenerator.uc:858-865","title":"Source code references"},{"location":"misc/ClassIsNative/","text":"ClassIsNative Tracking Issue: #767 To check whether a given class is native, use the static function CH_ClassIsNative . Example usage: CH_ClassIsNative(class'X2AbilityTarget_Single'); // True CH_ClassIsNative(UnitState.GetVisualizer().Class); // False because XGUnit is always non-native Source code references Object.uc:2405-2412","title":"ClassIsNative"},{"location":"misc/ClassIsNative/#source-code-references","text":"Object.uc:2405-2412","title":"Source code references"},{"location":"misc/ComponentVersions/","text":"ComponentVersions Tracking Issue: #765 Both the Highlander and mods using it may be interested in whether replacements for base game packages (\"components\") are installed, and if, which version. This can be used to Behave differently depending on whether a HL feature is available Provide more targeted error messages when a certain HL version is required For example, if you are interested in whether version 1.19.0 of the Highlander is correctly enabled, you can use the following: if (class'CHXComGameVersionTemplate' != none && (class'CHXComGameVersionTemplate'.default.MajorVersion > 1 || (class'CHXComGameVersionTemplate'.default.MajorVersion == 1 && class'CHXComGameVersionTemplate'.default.MinorVersion >= 19) ) ) { // Installed, do thing A } else { // Not installed or wrong version, do thing B } For other classes, see Source code references below. Note that you can employ feature-based detection if the feature can be distinguished by the presence of a certain function or property. For example, OverrideUnitFocusUI can be detected with the following trick: if (Function'XComGame.CHHelpers.GetFocusTuple' != none) { // Feature present } else { // Feature absent } Source code references CHXComGameVersionTemplate.uc:12-55 CHCoreVersion.uc:1-1 CHEngineVersion.uc:1-1 CHX2WOTCCHVersion.uc:1-1","title":"ComponentVersions"},{"location":"misc/ComponentVersions/#source-code-references","text":"CHXComGameVersionTemplate.uc:12-55 CHCoreVersion.uc:1-1 CHEngineVersion.uc:1-1 CHX2WOTCCHVersion.uc:1-1","title":"Source code references"},{"location":"misc/CustomInventorySlots/","text":"CustomInventorySlots Tracking Issue: #118 Tags: loadoutslots This feature defines additional inventory slots in the Highlander for mods to use. Configuration is done via CHItemSlot . More docs to follow. enum EInventorySlot { eInvSlot_Unknown, eInvSlot_Armor, eInvSlot_PrimaryWeapon, eInvSlot_SecondaryWeapon, eInvSlot_HeavyWeapon, eInvSlot_Utility, eInvSlot_Mission, eInvSlot_Backpack, eInvSlot_Loot, eInvSlot_GrenadePocket, eInvSlot_CombatSim, eInvSlot_AmmoPocket, eInvSlot_TertiaryWeapon, eInvSlot_QuaternaryWeapon, eInvSlot_QuinaryWeapon, eInvSlot_SenaryWeapon, eInvSlot_SeptenaryWeapon, // Add a marker slot, and buffer in case Firaxis adds more in the future // ALL MARKER SLOTS SHOULD NOT BE USED IN CODE OTHER THAN XCOMGAME // CHItemSlotTemplate has static helper functions for this purpose! // Since enums are compile-time constants, mods may have old values // that don't apply anymore for markers. eInvSlot_END_VANILLA_SLOTS, eInvSlot_Buffer018, eInvSlot_Buffer019, eInvSlot_Buffer020, eInvSlot_Buffer021, eInvSlot_Buffer022, eInvSlot_Buffer023, eInvSlot_Buffer024, eInvSlot_Buffer025, eInvSlot_Buffer026, eInvSlot_Buffer027, eInvSlot_Buffer028, eInvSlot_Buffer029, eInvSlot_Buffer030, eInvSlot_Buffer031, // again, don't use in mod code eInvSlot_BEGIN_TEMPLATED_SLOTS, // Custom slots begin here. We have space for ~220 slots, should be enough! // These slots can be used in Mod code and config values eInvSlot_Vest, eInvSlot_AugmentationHead, eInvSlot_AugmentationTorso, eInvSlot_AugmentationArms, eInvSlot_AugmentationLegs, eInvSlot_CombatDrugs, eInvSlot_Decorations, eInvSlot_PsiAmp, eInvSlot_Plating, eInvSlot_SparkLauncher, eInvSlot_ExtraSecondary, eInvSlot_PrimaryPayload, eInvSlot_SecondaryPayload, eInvSlot_ExtraRocket1, eInvSlot_ExtraRocket2, eInvSlot_ExtraRocket3, eInvSlot_ExtraRocket4, eInvSlot_Pistol, eInvSlot_Wings, eInvSlot_ExtraBackpack, eInvSlot_SparkGrenadePocket, eInvSlot_AuxiliaryWeapon, // Marker slot, don't use eInvSlot_END_TEMPLATED_SLOTS, }; If you need additional enum entries, request them in the tracking issue. Source code references X2TacticalGameRulesetDataStructures.uc:38-113 CHItemSlot.uc:13-13","title":"CustomInventorySlots"},{"location":"misc/CustomInventorySlots/#source-code-references","text":"X2TacticalGameRulesetDataStructures.uc:38-113 CHItemSlot.uc:13-13","title":"Source code references"},{"location":"misc/DLCAppendWeaponSockets/","text":"DLCAppendWeaponSockets Tracking Issue: #281 Tags: pawns Allows mods to add, move and rescale sockets on the skeletal mesh of any weapon, which can be used to position visual weapon attachments, using different position/scale of the same attachment's skeletal mesh for different weapons. Example use: static function DLCAppendWeaponSockets(out array<SkeletalMeshSocket> NewSockets, XComWeapon Weapon, XComGameState_Item ItemState) { local SkeletalMeshSocket Socket; local vector RelativeLocation; local rotator RelativeRotation; local vector RelativeScale; if (ItemState != none) { Socket = new class'SkeletalMeshSocket'; Socket.SocketName = 'NewSocket'; Socket.BoneName = 'root'; // Location offsets are in Unreal Units; 1 unit is roughly equal to a centimeter. RelativeLocation.X = 5; RelativeLocation.Y = 10; RelativeLocation.Z = 15; Socket.RelativeLocation = RelativeLocation; // Socket rotation is recorded as an int value [-65535; 65535], which corresponds with [-360 degrees; 360 degrees] // If we want to specify the rotation in degrees, the value must be converted using DegToUnrRot, a const in the Object class. RelativeRotation.Pitch = 5 * DegToUnrRot; // Pitch of five degrees. RelativeRotation.Yaw = 10 * DegToUnrRot; RelativeRotation.Roll = 15 * DegToUnrRot; Socket.RelativeRotation = RelativeRotation; // Scaling a socket will scale any mesh attached to it. RelativeScale.X = 0.25f; RelativeScale.Y = 0.5f; RelativeScale.Z = 1.0f; Socket.RelativeScale = RelativeScale; NewSockets.AddItem(Socket); } } Sockets that have the name of an existing socket will replace the original socket. This can be used to move, rotate, and rescale existing sockets. Source code references X2DownloadableContentInfo.uc:552-595","title":"DLCAppendWeaponSockets"},{"location":"misc/DLCAppendWeaponSockets/#source-code-references","text":"X2DownloadableContentInfo.uc:552-595","title":"Source code references"},{"location":"misc/DebugStartSecondWave/","text":"DebugStartSecondWave Tracking Issue: #197 A debug strategy start by default uses Beta Strike and no other second wave options. This change disables Beta Strike by default and makes the list configurable. XComGameData.ini : [XComGame.XGStrategy] ; uncomment for Beta Strike ;+DEBUG_SecondWaveOptions=\"BetaStrike\" Source code references XGStrategy.uc:762-764 XComGameData.ini:1-7","title":"DebugStartSecondWave"},{"location":"misc/DebugStartSecondWave/#source-code-references","text":"XGStrategy.uc:762-764 XComGameData.ini:1-7","title":"Source code references"},{"location":"misc/SubscribeToOnInput/","text":"SubscribeToOnInput Tracking Issue: #198 Tags: ui Mods may want to intercept mouse/keyboard/controller input and instead run their own code. For most purposes, this feature should be considered superseded by SubscribeToOnInputForScreen , which is more ergonomic to use and harder to misuse. Read that documentation page for a general overview. This feature does not allow receiving the notification only for a specific screen, which is usually what you want. Additionally, it is required to manually unsubscribe at some point, lest you invoke the wrath of the garbage collector and crash everyone's games. delegate bool CHOnInputDelegate(int iInput, int ActionMask); function SubscribeToOnInput(delegate<CHOnInputDelegate> callback); function UnsubscribeFromOnInput(delegate<CHOnInputDelegate> callback); Again, it is recommended to instead use SubscribeToOnInputForScreen . The documentation for that feature has examples. Source code references UIScreenStack.uc:785-801","title":"SubscribeToOnInput"},{"location":"misc/SubscribeToOnInput/#source-code-references","text":"UIScreenStack.uc:785-801","title":"Source code references"},{"location":"misc/SubscribeToOnInputForScreen/","text":"SubscribeToOnInputForScreen Tracking Issue: #501 Tags: ui Mods may want to intercept mouse/keyboard/controller input on certain screens and instead run their own code. For example, the Highlander adds a text to the main menu that has small pop-up accessible by pressing the right controller stick. The API consists of a delegate definition and two functions: delegate bool CHOnInputDelegateImproved(UIScreen Screen, int iInput, int ActionMask); function SubscribeToOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); function UnsubscribeFromOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); In a nutshell, with SubscribeToOnInputForScreen you ask the UIScreenStack \"when screen Screen would receive input, ask me first\". The CHOnInputDelegateImproved delegate defines the signature of the callback function called when the targeted screen would receive input. Your function will be called with three arguments: The screen that would have received the input ( Screen ), the button that was pressed ( iInput ), and the action that occured ( ActionMask , button press/release). The button and action are numeric values that correspond to constants in UIUtilities_Input.uc . If your function returns true, the ScreenStack will consider the input handled and immediately stop processing the input event. If your function returns false, the ScreenStack will continue calling other subscribers and, if unhandled, will finally notify the screen itself. You can manually unsubscribe from receiving input, but this is generally not necessary as your callback will only be called when the screen would have received input and will automatically be unsubscribed upon removal of the targeted screen. The following simplified example is taken from Covert Infiltration : class UIListener_Mission extends UIScreenListener; event OnInit (UIScreen Screen) { local UIMission MissionScreen; MissionScreen = UIMission(Screen); if (MissionScreen == none) return; // This is a UIMission screen, register MissionScreen.Movie.Stack.SubscribeToOnInputForScreen(MissionScreen, OnMissionScreenInput); } simulated protected function bool OnMissionScreenInput (UIScreen Screen, int iInput, int ActionMask) { if (!Screen.CheckInputIsReleaseOrDirectionRepeat(iInput, ActionMask)) { return false; } switch (iInput) { case class'UIUtilities_Input'.const.FXS_BUTTON_RTRIGGER: // The right controller trigger was just released, show custom screen // ... // Tell the ScreenStack that this input was handled return true; break; } return false; } CheckInputIsReleaseOrDirectionRepeat ensures that the button was just released (or, if directional button, held for a long time), making input behavior more consistent with base game screens. Although all mouse events can be inspected, Flash usually provides its own handlers that run even if the callback indicates to the ScreenStack that the input was handled. As a result, the only mouse event that can reliably be stopped with SubscribeToOnInputForScreen is the already navigation-relevant right click. This feature is a more convenient version of SubscribeToOnInput , which receives events for any screen and has to be manually unsubscribed. SubscribeToOnInput offers lower-level interaction with the input system at the cost of ergonomics. Source code references UIScreenStack.uc:843-919","title":"SubscribeToOnInputForScreen"},{"location":"misc/SubscribeToOnInputForScreen/#source-code-references","text":"UIScreenStack.uc:843-919","title":"Source code references"},{"location":"misc/TintMaterialConfigs/","text":"TintMaterialConfigs Tracking Issue: #356 Tags: customization , pawns When determining which values to pass to the material using which parameter names, the game matches against a hardcoded list of material names. As a result, mods need to confusingly name their modified materials exactly the same as base-game materials. This change moves these hardcoded names to config lists: var config(Content) array<name> HairMaterial; var config(Content) array<name> SkinMaterial; var config(Content) array<name> ArmorMaterial; var config(Content) array<name> WepAsArmorMaterial; var config(Content) array<name> EyeMaterial; var config(Content) array<name> FlagMaterial; You can add your own materials by creating the following lines in XComContent.ini : [XComGame.CHHelpers] +EyeMaterial=\"MyCustomEyesCustomizable_TC\" Source code references CHHelpers.uc:105-123 XComHumanPawn.uc:932-932 XComContent.ini:31-31","title":"TintMaterialConfigs"},{"location":"misc/TintMaterialConfigs/#source-code-references","text":"CHHelpers.uc:105-123 XComHumanPawn.uc:932-932 XComContent.ini:31-31","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshComponent/","text":"UpdateHumanPawnMeshComponent Tracking Issue: #216 Tags: customization , pawns Adds a DLC hook to update a given human pawn mesh component's materials. static function UpdateHumanPawnMeshComponent(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp); This can be used to apply custom materials to meshes, or set custom parameters. If not overridden, this calls UpdateHumanPawnMeshMaterial for every MaterialInstanceConstant. Call super.UpdateHumanPawnMeshComponent(UnitState, Pawn, MeshComp); if you rely on both hooks. Source code references X2DownloadableContentInfo.uc:453-464 XComHumanPawn.uc:972-972","title":"UpdateHumanPawnMeshComponent"},{"location":"misc/UpdateHumanPawnMeshComponent/#source-code-references","text":"X2DownloadableContentInfo.uc:453-464 XComHumanPawn.uc:972-972","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshMaterial/","text":"UpdateHumanPawnMeshMaterial Tracking Issue: #169 Tags: customization , pawns Adds a DLC hook to update a given material applied to a human pawn mesh component that can be used to set custom parameters on materials. static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC); This is called by UpdateHumanPawnMeshComponent if not overridden. UpdateHumanPawnMeshComponent allows more control over the materials, like being able to use MaterialInstanceTimeVarying or outright replacing materials. The following simplified example is taken from the Warhammer 40,000: Armours of the Imperium mod. Its armor uses custom material names and requires that the eye color is passed to the material using EmissiveColor instead of EyeColor : static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC) { local XComLinearColorPalette Palette; local LinearColor ParamColor; if (MaterialInstanceConstant(MIC.Parent).Name == 'Mat_SpaceMarine_Eyes') { Palette = `CONTENT.GetColorPalette(ePalette_EyeColor); ParamColor = Palette.Entries[Pawn.m_kAppearance.iEyeColor].Primary; MIC.SetVectorParameterValue('EmissiveColor', ParamColor); } } Note that a subset of this functionality (specifically if the material parameter names match) can be implemented with config only (no code) using the TintMaterialConfigs feature. Source code references X2DownloadableContentInfo.uc:407-440","title":"UpdateHumanPawnMeshMaterial"},{"location":"misc/UpdateHumanPawnMeshMaterial/#source-code-references","text":"X2DownloadableContentInfo.uc:407-440","title":"Source code references"},{"location":"misc/XComLWTuple/","text":"XComLWTuple Tracking Issue: #754 Tags: events XComLWTuple is based on the original LWTuple that many other mods package themselves, but it cannot be used interchangeably with that class. That means you have to use XComLWTuple for community highlander hooks that rely on it. LWTuple can be used to pass information between two mods without those mods needing to share any additional class types. Typically this information is passed using the XCOM2 event system: an event trigger passes an LWTuple as the EventData, and the listeners can retrieve this LWTuple. Data can be passed in both directions through this system, and the only type they both need to know about is LWTuple. LWTuples contain an id (a name) and an array of LWTValue values. The name is arbitrary and can be used to allow the sender and receiver to validate they are working with the tuple they are expecting. The data array holds the actual data to pass. LWTValue values are a union-like structure, similar to the ASValue struct used by the Scaleform system. A value can hold a bool, int, float, string, name, or object. Values are used by setting the field corresponding to the type you wish to store (e.g. i for int) and setting the kind field to the corresponding enum value (LWTVInt in this case). Readers should read only the field corresponding to the kind set in the value. To use a tuple with the event system, the code firing the event should \"new\" a LWTuple, set its ID field to an appropriate name, optionally fill in any information needed by the event listeners, and pass it as the EventData for the event. Listeners should cast the EventData back to a LWTuple, validate that the result is not none, that its ID is the one they are expecting, and that any contents are as expected. They can then store any new data needed into the tuple by adding to the data array before returning from the listener. These listeners should typically use ELDImmediate as their deferral mode so that the results are immediately processed and passed back to the caller, although mods may advertise longer-lived tuples that can be processed with other deferral strategies. Note that since multiple mods can all be listening on the same event there may be multiple mods receiving the same tuple. If more than one mod needs to return data in a tuple that was not intended to receive data from more than one mod a conflict occurs and these mods may be incompatible. List of data types The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles }; Source code references XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"XComLWTuple"},{"location":"misc/XComLWTuple/#list-of-data-types","text":"The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles };","title":"List of data types"},{"location":"misc/XComLWTuple/#source-code-references","text":"XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"Source code references"},{"location":"strategy/CovertAction_OverrideCostScalar/","text":"CovertAction_OverrideCostScalar Tracking Issue: #807 Allows listeners to override the multiplier covert actions use to determine how many resources an optional cost requires. The game uses 0.5 by default, which means CAs need half the supplies/intel/etc. you would get from a POI as the cost to mitigate a risk. EventID: CovertAction_OverrideCostScalar EventData: XComLWTuple { Data: [ inout float DefaultCostScalar, in XComGameState_Reward RewardState ] } EventSource: self (XCGS_CovertAction) NewGameState: no Source code references XComGameState_CovertAction.uc:578-594","title":"CovertAction_OverrideCostScalar"},{"location":"strategy/CovertAction_OverrideCostScalar/#source-code-references","text":"XComGameState_CovertAction.uc:578-594","title":"Source code references"},{"location":"strategy/CovertAction_OverrideRewardScalar/","text":"CovertAction_OverrideRewardScalar Tracking Issue: #807 Allows listeners to override the multiplier covert actions use to determine how many resources to award. The game uses 0.5 by default, which means CAs award half the supplies/intel/etc. you would get from a POI. EventID: CovertAction_OverrideRewardScalar EventData: XComLWTuple { Data: [ inout float DefaultRewardScalar, in XComGameState_Reward RewardState ] } EventSource: self (XCGS_CovertAction) NewGameState: no Source code references XComGameState_CovertAction.uc:612-627","title":"CovertAction_OverrideRewardScalar"},{"location":"strategy/CovertAction_OverrideRewardScalar/#source-code-references","text":"XComGameState_CovertAction.uc:612-627","title":"Source code references"},{"location":"strategy/FirstPromotionOverrideClass/","text":"FirstPromotionOverrideClass Tracking Issue: #801 The XComGameState_Unit::RankUpSoldier triggers a FirstPromotionOverrideClass event, allowing mods to override the soldier class template name that will be assigned to this unit, making it possible to set a class for the soldier based on arbitrary conditions. It is necessary to listen to this event using ELD_Immediate deferral in order for your changes to take effect in time. If the RankUpSoldier function was called with a soldier class template name already specified, it means the game wanted to promote this soldier to a specific class (e.g. GTS rookie training, Psi Operative training or Commander's Choice). In that case, you can set up your Event Listener to not have an effect on such a soldier. EventID: FirstPromotionOverrideClass EventData: XComLWTuple { Data: [ inout name SoldierClassTemplateName ] } EventSource: self (XComGameState_Unit) NewGameState: yes Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // If the game did not want to promote this soldier to a specific soldier class if (Tuple.Data[0].n == '') { // If a soldier rolled high aim thanks to Not Created Equal, they are guaranteed to become a sniper. if (UnitState.GetCurrentStat(eStat_Offense) > 70) { Tuple.Data[0].n = 'Sharpshooter'; } } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:12796-12837","title":"FirstPromotionOverrideClass"},{"location":"strategy/FirstPromotionOverrideClass/#source-code-references","text":"XComGameState_Unit.uc:12796-12837","title":"Source code references"},{"location":"strategy/OnBestGearLoadoutApplied/","text":"OnBestGearLoadoutApplied Tracking Issue: #676 The XComGameState_Unit::ApplyBestGearLoadout does not perform CanAddItemToInventory checks when it picks the best gear for the soldier, so if one of the selected items by that function cannot be equipped due to an override in CanAddItemToInventory_CH, the inventory slot will remain empty. This event passes along the Unit State whenever this function is called, so the mods can use their arbitrary conditions to decide what is the actual best gear loadout is for a unit. ID: OnBestGearLoadoutApplied Data: self (XCGS_Unit) Source: self (XCGS_Unit) NewGameState: yes // This EventFn requires the Event Listener to use an ELD_Immediate deferral. static function EventListenerReturn OnBestGearLoadoutApplied_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComGameState_Unit UnitState; // This gets you Unit State from History. UnitState = XComGameState_Unit(EventData); // Here you can *read* the Unit State. // Get the Unit State from the pending New Game State. UnitState = XComGameState_Unit(NewGameState.GetGameStateForObjectID(UnitState.ObjectID)); // Now you can make changes to the Unit State, such as changing its equipment based on arbitrary conditions. } Source code references XComGameState_Unit.uc:11164-11191","title":"OnBestGearLoadoutApplied"},{"location":"strategy/OnBestGearLoadoutApplied/#source-code-references","text":"XComGameState_Unit.uc:11164-11191","title":"Source code references"},{"location":"strategy/OverrideDarkEventCount/","text":"OverrideDarkEventCount Tracking Issue: #711 Triggers the event OverrideDarkEventCount to allow mods to change the number of dark events in the monthly report. EventID: OverrideNextRetaliationDisplay EventData: XComLWTuple { Data: [ inout int NumEvents, inout bool bChosenAddedEvent ] } EventSource: XComGameState_HeadquartersAlien NewGameState: Yes Source code references XComGameState_HeadquartersAlien.uc:1795-1809","title":"OverrideDarkEventCount"},{"location":"strategy/OverrideDarkEventCount/#source-code-references","text":"XComGameState_HeadquartersAlien.uc:1795-1809","title":"Source code references"},{"location":"strategy/OverrideHasAmmoPocket/","text":"OverrideHasAmmoPocket Tracking Issue: #735 Tags: loadoutslots Extends the ability check in HasAmmoPocket() for the config array AbilityUnlocksAmmoPocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasAmmoPocket is triggered that allows mods to override the final result EventID: OverrideHasAmmoPocket EventData: XComLWTuple { Data: [ inout bool bHasAmmoPocket ] } EventSource: XComGameState_Unit NewGameState: no Source code references XComGameState_Unit.uc:3883-3897","title":"OverrideHasAmmoPocket"},{"location":"strategy/OverrideHasAmmoPocket/#source-code-references","text":"XComGameState_Unit.uc:3883-3897","title":"Source code references"},{"location":"strategy/OverrideHasExtraUtilitySlot/","text":"OverrideHasExtraUtilitySlot Tracking Issue: #735 Tags: loadoutslots Extends the ability check in HasExtraUtilitySlot() for the config array AbilityUnlocksExtraUtilitySlot ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasExtraUtilitySlot is triggered that allows mods to override the final result EventID: OverrideHasExtraUtilitySlot EventData: XComLWTuple { Data: [ inout bool bHasExtraUtilitySlot ] } EventSource: XComGameState_Unit NewGameState: no Source code references XComGameState_Unit.uc:3912-3926","title":"OverrideHasExtraUtilitySlot"},{"location":"strategy/OverrideHasExtraUtilitySlot/#source-code-references","text":"XComGameState_Unit.uc:3912-3926","title":"Source code references"},{"location":"strategy/OverrideHasGrenadePocket/","text":"OverrideHasGrenadePocket Tracking Issue: #735 Tags: loadoutslots Extends the ability check in HasGrenadePocket() for the config array AbilityUnlocksGrenadePocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasGrenadePocket is triggered that allows mods to override the final result EventID: OverrideHasGrenadePocket EventData: XComLWTuple { Data: [ inout bool bHasGrenadePocket ] } EventSource: XComGameState_Unit NewGameState: no Source code references XComGameState_Unit.uc:3855-3869","title":"OverrideHasGrenadePocket"},{"location":"strategy/OverrideHasGrenadePocket/#source-code-references","text":"XComGameState_Unit.uc:3855-3869","title":"Source code references"},{"location":"strategy/OverrideNextRetaliationDisplay/","text":"OverrideNextRetaliationDisplay Tracking Issue: #667 The Dark Events Screen ( UIAdventOperations ) by default shows a string like: \"Next Retaliation: 6 Weeks (Estimated)\". This event allows mods to override whether to show that text, and customize the actual displayed text. EventID: OverrideNextRetaliationDisplay EventData: XComLWTuple { Data: [ inout bool bShow, inout string strHeader, inout string strValue, inout string strFooter ] } Source code references UIAdventOperations.uc:253-268","title":"OverrideNextRetaliationDisplay"},{"location":"strategy/OverrideNextRetaliationDisplay/#source-code-references","text":"UIAdventOperations.uc:253-268","title":"Source code references"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/","text":"PreCompleteStrategyFromTacticalTransfer Tracking Issue: #785 There are no events that trigger before the mission rewards and several other critical functions are processed. This event gives a way for mods to change several aspects in the transition from tactical to strategy. EventID: PreCompleteStrategyFromTacticalTransfer EventData: None EventSource: None NewGameState: None Source code references XComGameStateContext_StrategyGameRule.uc:331-341","title":"PreCompleteStrategyFromTacticalTransfer"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#source-code-references","text":"XComGameStateContext_StrategyGameRule.uc:331-341","title":"Source code references"},{"location":"strategy/PreDarkEventDeactivated/","text":"PreDarkEventDeactivated Tracking Issue: #753 Notifies listeners of when a dark event has expired/been deactivated. This event fires before the dark event's deactivation code runs, so register an ELD_Immediate listener if you want access to the state before that happens, or an ELD_OnStateSubmitted listener if you want the state after the full deactivation. EventID: PreDarkEventDeactivated EventData: XCGS_DarkEvent EventSource: XCGS_DarkEvent NewGameState: yes Source code references XComGameState_DarkEvent.uc:218-230","title":"PreDarkEventDeactivated"},{"location":"strategy/PreDarkEventDeactivated/#source-code-references","text":"XComGameState_DarkEvent.uc:218-230","title":"Source code references"},{"location":"strategy/ShowItemInLockerList/","text":"ShowItemInLockerList Tracking Issue: #844 Tags: events Allows listeners to override the result of SlotShowItemInLockerList EventID: OverrideShowItemInLockerList EventData: XComLWTuple { Data: [ inout bool bSlotShowItemInLockerList, inout EInventorySlot Slot, inout XComGameState_Unit UnitState ] } EventSource: XComGameState_Item ItemState GameState: optional Source code references CHItemSlot.uc:402-416","title":"ShowItemInLockerList"},{"location":"strategy/ShowItemInLockerList/#source-code-references","text":"CHItemSlot.uc:402-416","title":"Source code references"},{"location":"strategy/ValidateGTSClassTraining/","text":"ValidateGTSClassTraining Tracking Issue: #814 Tags: events Triggers an 'ValidateGTSClassTraining' event that allows listeners to control whether the given class can be trained in the GTS. The event is fired once for each class whenever the GTS creates a list of classes to train. The boolean value is based on vanilla checks (NumInForcedDeck and bMultiplayerOnly), so vanilla behavior is maintained when the value isn't changed by the listener(s), and listeners can base their logic on the vanilla checks or override the result. EventID: ValidateGTSClassTraining EventData: XComLWTuple { Data: [ out bool CanTrainClass, in X2SoldierClassTemplate SoldierClassTemplate ] } EventSource: self (UIChooseClass) NewGameState: no Source code references UIChooseClass.uc:128-148","title":"ValidateGTSClassTraining"},{"location":"strategy/ValidateGTSClassTraining/#source-code-references","text":"UIChooseClass.uc:128-148","title":"Source code references"},{"location":"tactical/DamageCalc_ArmorBeforeShield/","text":"DamageCalc_ArmorBeforeShield Tracking Issue: #743 By default, shields are damaged before any damage is mitigated by armor. This is fine in vanilla when shields are rare, but becomes an issue in modded campaigns where 'shields' are turned into 'ablative' hit points that provide a buffer before units become wounded and suffer red fog. Increasing ablative is often a non-optimal choice because it can make the the soldier's armor pips become redundant. This change adds an optional config variable (XComGameCore.ini) that other mods or the player can enable. When enabled, it changes the TakeDamage event inside XComGameState_Unit to handle armor mitigation and apply any shredding to the armor before moving on to shields. Shield-bypassing damage such as Psi or EMP damage behaves as normal, ignoring armor and shields to hit health. [XComGame.X2Effect_ApplyWeaponDamage] ; Issue 743 ; Set to false/commented out if you want damage to hit shields/ablative, then armor, then health (vanilla behaviour) ; Set to true/uncomment it if you want damage to hit armor, then shield/ablative, then health ;ARMOR_BEFORE_SHIELD=true Source code references XComGameState_Unit.uc:6228-6248","title":"DamageCalc_ArmorBeforeShield"},{"location":"tactical/DamageCalc_ArmorBeforeShield/#source-code-references","text":"XComGameState_Unit.uc:6228-6248","title":"Source code references"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/","text":"DisplayCustomOverwatchActionPointOnUnitFlag Tracking Issue: #724 Tags: compatibility The base XCOM 2 behavior is to show an Overwatch \"eye\" icon under the unit flag only if the soldier has at least one \"overwatch\" Reserve Action Point. The icon is not displayed for Pistol Overwatch. This change addresses that issue, and also allows mods that add weapons with custom Overwatch Action Point to specify that action point name in XComGame.ini: [XComGame.CHHelpers] +ValidReserveAPForUnitFlag = \"overwatch\" +ValidReserveAPForUnitFlag = \"pistoloverwatch\" Compatibility: If you override UIUnitFlag::RealizeOverwatch , your code may undo this change. Source code references UIUnitFlag.uc:1699-1712","title":"DisplayCustomOverwatchActionPointOnUnitFlag"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/#source-code-references","text":"UIUnitFlag.uc:1699-1712","title":"Source code references"},{"location":"tactical/OverKillDamage/","text":"OverKillDamage Tracking Issue: #805 The UnitState's damage results array only holds the actual damage taken by the unit, so the result can't be higher than the unit's HP. This adds the OverkillDamage Unit value, which is shows how higher the kill damage value was from the standard Unit HP. One of its use cases is to modify the effects of the abilities that trigger on death, like the trigger chance on Advent Priest's Sustain. The OverKillDamage calculated by XCGS_Unit is negative, but the unit value is set to be positive to make using it more intuitive. The value uses eCleanup_BeginTactical . Source code references XComGameState_Unit.uc:15001-15006","title":"OverKillDamage"},{"location":"tactical/OverKillDamage/#source-code-references","text":"XComGameState_Unit.uc:15001-15006","title":"Source code references"},{"location":"tactical/OverrideHasInfiniteAmmo/","text":"OverrideHasInfiniteAmmo Tracking Issue: #842 Tags: events Allows listeners to override the result of HasInfiniteAmmo EventID: OverrideHasInfiniteAmmo EventData: XComLWTuple { Data: [ out bool bHasInfiniteAmmo ] } EventSource: XComGameState_Item (self) NewGameState: no Source code references XComGameState_Item.uc:969-981","title":"OverrideHasInfiniteAmmo"},{"location":"tactical/OverrideHasInfiniteAmmo/#source-code-references","text":"XComGameState_Item.uc:969-981","title":"Source code references"},{"location":"tactical/OverrideHitEffects/","text":"OverrideHitEffects Tracking Issue: #825 Allows listeners to override the default behavior of XComUnitPawn.PlayHitEffects This is especially useful for preventing the hardcoded templar fx for eHit_Parry, eHit_Reflect and eHit_Deflect which play for any abilities that utilizing these hit results. If OverrideHitEffect is set to true the PlayHitEffects function will return early and the default behavior is ommited. EventID: OverrideHitEffects EventData: XComLWTuple { Data: [ out bool OverrideHitEffect, inout float Damage, inout Actor InstigatedBy, inout vector HitLocation, inout name DamageTypeName, inout vector Momentum, inout bool bIsUnitRuptured, inout EAbilityHitResult HitResult, ] } EventSource: self (XComUnitPawn) NewGameState: no Source code references XComUnitPawn.uc:380-402","title":"OverrideHitEffects"},{"location":"tactical/OverrideHitEffects/#source-code-references","text":"XComUnitPawn.uc:380-402","title":"Source code references"},{"location":"tactical/OverrideProjectileInstance/","text":"OverrideProjectileInstance Tracking Issue: #829 Tags: events Allows listeners to override the parameters of SpawnAndConfigureNewProjectile The feature also introduces support for subclasses of X2UnifiedProjectile as custom projectile archetypes. If bPreventProjectileSpawning is set to true the projectile instance will NOT be spawned. EventID: OverrideProjectileInstance EventData: XComLWTuple { Data: [ out bool bPreventProjectileSpawning in actor ProjectileTemplate, in AnimNotify_FireWeaponVolley InVolleyNotify in XComWeapon InSourceWeapon inout X2Action_Fire CurrentFireAction, in XGUnitNativeBase self ] } EventSource: XComGameStateContext_Ability AbilityContext NewGameState: no Source code references XGUnitNativeBase.uc:1614-1633","title":"OverrideProjectileInstance"},{"location":"tactical/OverrideProjectileInstance/#source-code-references","text":"XGUnitNativeBase.uc:1614-1633","title":"Source code references"},{"location":"tactical/OverrideUnitFocusUI/","text":"OverrideUnitFocusUI Tracking Issue: #257 Tags: compatibility This focus change allows mods to change the focus UI that the vanilla game uses to display Templar Focus. This effectively creates different types of Focus, even though the game does not know about this. For example, you can create a custom soldier class with its own type of focus, tracked with a UnitValue . This imposes a few limitations on the system: A given unit only ever has a single \"type\" of focus. The rules for different focus types are expected to be so different from one another to make any conflicts a painful experience for modders and players. In particular, it means that this function should NOT be used to make any changes to the Templar Focus, as tempting as it may be. This also includes an Effect of the name TemplarFocus or an Effect Class of the type XComGameState_Effect_TemplarFocus . In order to add your custom focus types, there are two changes in XComGame you can use: A new event hook for UIUnitFlag and UITacticalHUD_SoldierInfo : Documentation for that particular hook is directly below. A change in X2AbilityCost_Focus : You may subclass that particular class and override all functions declared there ( CanAfford , ApplyCost , PreviewFocusCost ). This can be used to preview a cost for custom skills that consume focus. Again, make sure to not mix and match custom subclasses with the base class for any abilities. EventID: OverrideUnitFocusUI EventData: XComLWTuple { Data: [ inout bool bVisible, inout int currentFocus, inout int maxFoxus, inout string color, inout string iconPath, inout string tooltipText, inout string focusLabel ] } Note that if bVisible == false , the rest will be ignored and will not have valid data in it. Compatibility If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples. Source code references CHHelpers.uc:340-384","title":"OverrideUnitFocusUI"},{"location":"tactical/OverrideUnitFocusUI/#compatibility","text":"If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples.","title":"Compatibility"},{"location":"tactical/OverrideUnitFocusUI/#source-code-references","text":"CHHelpers.uc:340-384","title":"Source code references"},{"location":"tactical/PostAliensSpawned/","text":"PostAliensSpawned Tracking Issue: #457 This event triggers right after the alien pods are added into the tactical mission's Start State, before their visualizers are spawned/visualized. Overall it can be treated as an earlier alternative to 'OnTacticalBeginPlay' event. It can be used to make arbitrary changes to units that were just added to the Start State, including Soldier VIPs that are spawned for Gather Survivors missions. For example, this is how to set up an Event Listener to modify these Soldier VIPs: // This EventFn requires an ELD_Immediate deferral. static protected function EventListenerReturn PostAliensSpawned_Listener(Object EventData, Object EventSource, XComGameState StartState, Name EventID, Object CallbackData) { local XComTacticalMissionManager MissionManager; local XComGameState_Unit UnitState; local XComGameState_AIGroup GroupState; MissionManager = `TACTICALMISSIONMGR; if (MissionManager.ActiveMission.sType == \"GatherSurvivors\") { // Cycle through Group States, which are basically Game States for pods. foreach GameState.IterateByClassType(class'XComGameState_AIGroup', GroupState) { // Check the pod for correct markings. if (GroupState.EncounterID == 'ResistanceTeamMember_VIP' && GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_01') { // Assume the pod contains only one unit and grab the Unit State for it. UnitState = XComGameState_Unit(GameState.GetGameStateForObjectID(GroupState.m_arrMembers[0].ObjectID)); if (UnitState != none) { // Make arbitrary changes to the Unit here. } } // Do the same for GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_02' here. } } return ELR_NoInterrupt; } EventID: PostAliensSpawned NewGameState: StartState Source code references X2TacticalGameRuleset.uc:2413-2453","title":"PostAliensSpawned"},{"location":"tactical/PostAliensSpawned/#source-code-references","text":"X2TacticalGameRuleset.uc:2413-2453","title":"Source code references"}]}